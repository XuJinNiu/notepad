1.sizeof和strlen的区别和联系:
	a.sizeof()是运算符,strlen是函数.
	b.sizeof()是capacity	
		char str[20]="0123456789";
		int a=strlen(str); //a=10;--->strlen计算字符的长度,以0x00('\0')为字符串结束
		int b=sizeof(str); //而b=20;--->sizeof计算数组分配空间的大小,不受里面存储内容改变.
2. 
  初始化的全局变量和静态变量存放在 data段(全局初始化区) 
未初始化的全局变量和未初始化的静态变量存放在bss段（全局未初始化区），
其中BSS段的特点是：在程序执行之前BSS段会自动清0，
所以未初始化的全局变量和静态比那辆在程序执行之前就已经变成0，
但是并不是存放在初始化段，是因为存放在未初始化段才初始化为0的

3.	a: int(*p)[4]---p是指向含4个元素的以为一维整型数组的指针变量(指针) (*p)表示第一行,(*p)[2]表示a[0][2]
	b: int *p[4]----定义指针数组p,它由4个指向整型数据的指针元素组成(数组,但是存放了4个int指针)
	c: int(*)[4]---等价于int(*p)[4];	
4.引用,const成员变量,基类构造函数一定要通过初始化列表来实现,static类型不是类对象成员,不需要通过初始化列表来实现
  (static是类成员,不是对象成员).
5.静态成员函数	
	a:没有this指针
	b:不能为虚函数
	c:只能访问类的静态数据成员,不能访问类的普通数据成员
	d:类的普通成员函数可以调用静态成员函数,但是静态成员函数不能调用普通成员函数.
6.虚函数:
	a:只有类的成员函数才能说明为虚函数
	b:静态成员函数不能是虚函数
	c:inline函数不能为虚函数
	d:构造函数不能为虚函数
	e:析构函数通常为虚函数(如果做基类的话)
7.&按位与运算符
	0&0=0	0&1=0	1&0=0	1&1=1
	a:用于整数偶奇性判断.a&1=0  a是偶数,a&1=1 a是奇数
8.^按位异或
	0^1=1	1^0=1	0^0=0	1^1=0(一样就是0,不一样就是1)
	a:交换两个整数的值而不用第三个参数
		x=3(011)	y=4(100)
		x=x^y	011^100=111
		y=x^y	111^100=011=3
		x=x^y	111^011=100=4
	b:数组中只出现一次的数字(两个相同的数字异或结果为0)

9./和%的优先级一样.
10.指针指向字符串时,字符串是常量,存储在常量区,而指针存储在栈区,不能对其进行修改.
11.函数重载不考虑函数的返回值
12.sizeof(类)计算的是类中存在栈中的变量大小(静态变量存在全局区).
13.
	struct A{
		void foo(){printf("foo");}
		virtual void bar(){printf("bar");}
		A(){bar();}
	};
	struct B:A{
		void foo(){printf("b_foo");}
		void bar(){printf("b_bar");}
	};
	A *p=new B;//A类指针实例化对象B,B类继承A类,先调用A类构造函数,bar()输出bar,B类没有显示构造函数
	p->foo();//执行B类里面的foo(),因为foo不是虚函数,所以直接调用父类的foo函数,输出foo
	p->bar();//执行B类里的bar()函数,因为bar函数是虚函数,调用子类的实现,输出b_bar
14.private:a.该类的函数可以访问 b.其友元函数可以访问 c.不能被任何其他类访问,该类的对象也不可以
   protected:a.该类的函数可以访问 b.子类的函数 c.其友元函数可以访问 d.不能被该类的对象访问
   public:a.该类的函数可以访问 b.子类的函数可以访问 c.其友元函数可以访问 d.该类的对象可以访问
   (友元函数包括:a.设为友元的普通非成员函数 b.设为友元的其他类的成员函数 c.设为友元类的所有成员函数)
